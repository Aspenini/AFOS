#!/usr/bin/env python3
"""
Build script to embed sys/ directory into the kernel filesystem.
Generates sysfs_data.c which contains all files from sys/ directory.
"""

import os
import sys

def escape_c_string(s):
    """Escape a string for use in C source code."""
    result = []
    for c in s:
        if c == '\\':
            result.append('\\\\')
        elif c == '"':
            result.append('\\"')
        elif c == '\n':
            result.append('\\n')
        elif c == '\r':
            result.append('\\r')
        elif c == '\t':
            result.append('\\t')
        elif ord(c) >= 32 and ord(c) < 127:
            result.append(c)
        else:
            result.append(f'\\x{ord(c):02x}')
    return ''.join(result)

def collect_files(base_dir):
    """Collect all files from sys/ directory, preserving structure."""
    files = []
    base_len = len(base_dir)
    
    for root, dirs, filenames in os.walk(base_dir):
        # Skip hidden files and directories
        dirs[:] = [d for d in dirs if not d.startswith('.')]
        filenames = [f for f in filenames if not f.startswith('.')]
        
        for filename in filenames:
            filepath = os.path.join(root, filename)
            rel_path = filepath[base_len:].lstrip('/')
            files.append((rel_path, filepath))
    
    return files

def is_binary_file(filepath):
    """Check if a file should be treated as binary."""
    # Binary extensions for AFOS
    binary_extensions = ['.afos', '.bin', '.exe', '.app', '.o', '.obj']
    return any(filepath.endswith(ext) for ext in binary_extensions)

def generate_c_file(files, output_file):
    """Generate C source file with embedded file data."""
    with open(output_file, 'w') as f:
        f.write("/* Auto-generated file system data from sys/ directory */\n")
        f.write("/* DO NOT EDIT - Generated by build_sysfs.py */\n\n")
        f.write("#include \"filesystem.h\"\n")
        f.write("#include \"types.h\"\n\n")
        f.write("extern fs_node_t* fs_root;\n")
        f.write("extern fs_node_t* fs_current_dir;\n\n")
        
        # Generate file data arrays
        file_vars = []
        for i, (rel_path, filepath) in enumerate(files):
            var_name = f"sysfs_file_{i}"
            size_var = f"sysfs_file_{i}_size"
            is_binary = is_binary_file(filepath)
            
            with open(filepath, 'rb') as infile:
                content = infile.read()
            
            file_vars.append((var_name, size_var, rel_path, len(content), is_binary))
            
            f.write(f"/* {rel_path} */\n")
            if is_binary:
                # Binary files: use unsigned char array
                f.write(f"static const uint8_t {var_name}[] = {{")
                for j, byte in enumerate(content):
                    if j % 16 == 0:
                        f.write("\n    ")
                    f.write(f"0x{byte:02x}")
                    if j < len(content) - 1:
                        f.write(",")
                    if j % 16 != 15 and j < len(content) - 1:
                        f.write(" ")
                f.write(f"\n}};\n")
                f.write(f"static const uint32_t {size_var} = {len(content)};\n\n")
            else:
                # Text files: use string literal (but store as uint8_t for consistency)
                f.write(f"static const uint8_t {var_name}[] = {{")
                for j, byte in enumerate(content):
                    if j % 16 == 0:
                        f.write("\n    ")
                    f.write(f"0x{byte:02x}")
                    if j < len(content) - 1:
                        f.write(",")
                    if j % 16 != 15 and j < len(content) - 1:
                        f.write(" ")
                f.write(f"\n}};\n")
                f.write(f"static const uint32_t {size_var} = {len(content)};\n\n")
        
        # Generate initialization function
        f.write("/* Initialize filesystem with files from sys/ directory */\n")
        f.write("void sysfs_initialize(void) {\n")
        f.write("    fs_node_t* current = fs_root;\n")
        f.write("    // Navigate to /sys directory\n")
        f.write("    fs_node_t* sys_node = fs_find_child(current, \"sys\");\n")
        f.write("    if (sys_node == NULL) {\n")
        f.write("        return; // sys directory should already exist\n")
        f.write("    }\n")
        f.write("    current = sys_node;\n\n")
        
        # Track current directory path (starting from sys)
        current_path = ["sys"]
        
        for file_idx, (var_name, size_var, rel_path, file_size, is_binary) in enumerate(file_vars):
            # Parse path and create directories/files
            parts = rel_path.split('/')
            filename = parts[-1]
            dir_parts = parts[:-1]  # Empty if file is directly in sys/
            
            # Navigate to target directory
            # Find common prefix with current path
            common_len = 0
            for i in range(min(len(current_path), len(dir_parts))):
                if current_path[i] == dir_parts[i]:
                    common_len = i + 1
                else:
                    break
            
            # Go back to common ancestor (but NEVER go back past sys)
            # We always start at sys, so we should never go back to root
            if common_len < len(current_path):
                steps_back = len(current_path) - common_len
                # Special cases where we should NOT go back past sys:
                # 1. File is directly in sys/ (dir_parts is empty) - stay in sys
                # 2. We're in sys and navigating to a subdirectory - stay in sys
                if (len(dir_parts) == 0) or \
                   (common_len == 0 and len(current_path) > 0 and current_path[0] == "sys" and len(dir_parts) > 0):
                    # Don't go back - stay at current level (sys)
                    steps_back = 0
                    # For empty dir_parts, we're already in the right place
                    # For subdirectory, we'll navigate forward next
                    if len(dir_parts) == 0:
                        common_len = len(current_path)  # Stay where we are
                    else:
                        common_len = 0  # Will navigate from start of dir_parts
                else:
                    for _ in range(steps_back):
                        f.write("    current = current->parent;\n")
                current_path = current_path[:common_len]
            
            # Navigate forward to target
            for i in range(common_len, len(dir_parts)):
                dir_part = dir_parts[i]
                if dir_part:
                    # Use a unique variable name to avoid conflicts
                    dir_var_name = f"dir_{file_idx}_{i}_{dir_part.replace('-', '_').replace('.', '_')}"
                    f.write(f"    fs_node_t* {dir_var_name} = fs_find_child(current, \"{dir_part}\");\n")
                    f.write(f"    if ({dir_var_name} == NULL) {{\n")
                    f.write(f"        fs_mkdir(current, \"{dir_part}\");\n")
                    f.write(f"        {dir_var_name} = fs_find_child(current, \"{dir_part}\");\n")
                    f.write(f"    }}\n")
                    f.write(f"    current = {dir_var_name};\n")
                    current_path.append(dir_part)
            
            # Create file (file is in current directory)
            f.write(f"    fs_create_file(current, \"{filename}\", {var_name}, {size_var});\n\n")
        
        f.write("}\n")

def main():
    base_dir = "sys"
    output_file = "kernel/sysfs_data.c"
    
    if not os.path.exists(base_dir):
        print(f"Warning: {base_dir} directory does not exist. Creating empty sysfs_data.c")
        with open(output_file, 'w') as f:
            f.write("/* Auto-generated file system data from sys/ directory */\n")
            f.write("/* sys/ directory not found */\n\n")
            f.write("#include \"filesystem.h\"\n")
            f.write("#include \"types.h\"\n\n")
            f.write("void sysfs_initialize(void) {\n")
            f.write("    /* No files to load */\n")
            f.write("}\n")
        return 0
    
    files = collect_files(base_dir)
    
    if not files:
        print(f"Warning: No files found in {base_dir} directory")
        with open(output_file, 'w') as f:
            f.write("/* Auto-generated file system data from sys/ directory */\n")
            f.write("/* No files found in sys/ */\n\n")
            f.write("#include \"filesystem.h\"\n")
            f.write("#include \"types.h\"\n\n")
            f.write("void sysfs_initialize(void) {\n")
            f.write("    /* No files to load */\n")
            f.write("}\n")
        return 0
    
    print(f"Found {len(files)} file(s) in {base_dir}/")
    for rel_path, _ in files:
        print(f"  - {rel_path}")
    
    generate_c_file(files, output_file)
    print(f"Generated {output_file}")
    return 0

if __name__ == "__main__":
    sys.exit(main())

